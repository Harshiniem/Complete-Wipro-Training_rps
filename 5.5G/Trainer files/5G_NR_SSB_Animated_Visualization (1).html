<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>5G NR SSB â€” Animated Technical Visualization</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;500;600;700;800&family=JetBrains+Mono:wght@300;400;500;600&display=swap');

:root {
  --bg-deep: #060a14;
  --bg-mid: #0a1020;
  --bg-card: rgba(12, 18, 40, 0.85);
  --glass-border: rgba(100, 170, 255, 0.12);
  --glass-shine: rgba(140, 200, 255, 0.06);
  --text-primary: #e0eaff;
  --text-secondary: rgba(180, 200, 240, 0.7);
  --text-dim: rgba(140, 165, 210, 0.45);
  --pss: #38bdf8;
  --pss-glow: rgba(56, 189, 248, 0.3);
  --sss: #a78bfa;
  --sss-glow: rgba(167, 139, 250, 0.3);
  --pbch: #34d399;
  --pbch-glow: rgba(52, 211, 153, 0.25);
  --dmrs: #fbbf24;
  --dmrs-glow: rgba(251, 191, 36, 0.25);
  --accent: #60a5fa;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html { scroll-behavior: smooth; }

body {
  background: var(--bg-deep);
  color: var(--text-primary);
  font-family: 'Outfit', sans-serif;
  overflow-x: hidden;
  min-height: 100vh;
}

/* â”€â”€ Ambient background â”€â”€ */
body::before {
  content: '';
  position: fixed;
  top: -30%; left: -20%;
  width: 140%; height: 160%;
  background:
    radial-gradient(ellipse at 20% 20%, rgba(56,189,248,0.04) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 70%, rgba(167,139,250,0.04) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 50%, rgba(52,211,153,0.02) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}

.page { max-width: 1320px; margin: 0 auto; padding: 30px 24px 80px; position: relative; z-index: 1; }

/* â”€â”€ HEADER â”€â”€ */
.hero {
  text-align: center;
  padding: 50px 0 40px;
  position: relative;
}
.hero h1 {
  font-weight: 800;
  font-size: clamp(1.8rem, 4vw, 2.8rem);
  background: linear-gradient(135deg, var(--pss), var(--sss), var(--pbch));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: -1px;
  line-height: 1.15;
}
.hero .tagline {
  font-weight: 300;
  font-size: 1rem;
  color: var(--text-secondary);
  margin-top: 8px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.hero .spec {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.72rem;
  color: var(--text-dim);
  margin-top: 10px;
}
.hero::after {
  content: '';
  display: block;
  margin: 28px auto 0;
  width: 240px;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(100,180,255,0.4), rgba(167,139,250,0.4), transparent);
}

/* â”€â”€ Navigation â”€â”€ */
.nav-bar {
  display: flex;
  justify-content: center;
  gap: 6px;
  flex-wrap: wrap;
  margin-bottom: 40px;
  position: sticky;
  top: 0;
  z-index: 100;
  padding: 12px 0;
  background: rgba(6,10,20,0.88);
  backdrop-filter: blur(16px);
  border-bottom: 1px solid rgba(100,150,255,0.06);
}
.nav-btn {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.72rem;
  font-weight: 500;
  letter-spacing: 0.5px;
  padding: 7px 16px;
  border: 1px solid var(--glass-border);
  border-radius: 20px;
  background: var(--bg-card);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.3s;
}
.nav-btn:hover, .nav-btn.active {
  background: rgba(56,189,248,0.12);
  border-color: rgba(56,189,248,0.35);
  color: var(--pss);
}

/* â”€â”€ GLASS SECTION â”€â”€ */
.section {
  background: var(--bg-card);
  border: 1px solid var(--glass-border);
  border-radius: 22px;
  padding: 32px;
  margin-bottom: 32px;
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(12px);
}
.section::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--glass-shine), transparent 60%);
  pointer-events: none;
}
.section::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(100,180,255,0.3), transparent);
  pointer-events: none;
}

.sec-title {
  font-weight: 600;
  font-size: 1.15rem;
  color: #93c5fd;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 10px;
  position: relative;
  z-index: 1;
}
.sec-title .ico {
  width: 30px; height: 30px;
  background: linear-gradient(135deg, rgba(56,189,248,0.15), rgba(167,139,250,0.15));
  border: 1px solid rgba(100,160,255,0.2);
  border-radius: 8px;
  display: grid; place-items: center;
  font-size: 0.85rem;
}
.sec-desc {
  font-weight: 300;
  font-size: 0.85rem;
  color: var(--text-dim);
  margin-bottom: 24px;
  position: relative; z-index: 1;
}

/* â”€â”€ CANVAS CONTAINERS â”€â”€ */
.canvas-wrap {
  position: relative;
  width: 100%;
  border-radius: 14px;
  overflow: hidden;
  background: rgba(6,10,20,0.6);
  border: 1px solid rgba(100,150,255,0.08);
}
canvas {
  display: block;
  width: 100%;
  height: auto;
}

/* â”€â”€ CONTROLS â”€â”€ */
.controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 16px;
  flex-wrap: wrap;
  position: relative; z-index: 2;
}
.btn {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.74rem;
  font-weight: 500;
  padding: 8px 20px;
  border-radius: 10px;
  border: 1px solid var(--glass-border);
  background: rgba(20,30,60,0.7);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.25s;
  white-space: nowrap;
}
.btn:hover {
  background: rgba(56,189,248,0.15);
  border-color: rgba(56,189,248,0.4);
  color: var(--pss);
}
.btn.active {
  background: rgba(56,189,248,0.2);
  border-color: var(--pss);
  color: #e0f2fe;
  box-shadow: 0 0 16px rgba(56,189,248,0.15);
}

.speed-control {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
}
.speed-control label {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.68rem;
  color: var(--text-dim);
}
.speed-slider {
  -webkit-appearance: none;
  width: 80px;
  height: 4px;
  border-radius: 2px;
  background: rgba(100,150,255,0.15);
  outline: none;
}
.speed-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px; height: 14px;
  border-radius: 50%;
  background: var(--pss);
  cursor: pointer;
  box-shadow: 0 0 8px var(--pss-glow);
}

/* â”€â”€ STATUS BAR â”€â”€ */
.status-bar {
  margin-top: 14px;
  padding: 12px 18px;
  background: rgba(10,16,35,0.7);
  border: 1px solid rgba(100,150,255,0.08);
  border-radius: 10px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.78rem;
  color: var(--text-secondary);
  line-height: 1.6;
  min-height: 45px;
  position: relative; z-index: 2;
}
.status-bar .label {
  color: var(--pss);
  font-weight: 600;
}

/* â”€â”€ LEGEND â”€â”€ */
.legend {
  display: flex;
  gap: 18px;
  flex-wrap: wrap;
  margin-top: 14px;
  position: relative; z-index: 2;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.76rem;
  font-weight: 400;
  color: var(--text-secondary);
}
.legend-dot {
  width: 10px; height: 10px;
  border-radius: 3px;
}

/* â”€â”€ INFO PANELS â”€â”€ */
.info-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 16px;
  margin-top: 20px;
  position: relative; z-index: 2;
}
.info-panel {
  background: rgba(15,22,48,0.6);
  border: 1px solid rgba(100,150,255,0.08);
  border-radius: 12px;
  padding: 16px;
}
.info-panel h4 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.68rem;
  font-weight: 600;
  color: rgba(147,197,253,0.7);
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-bottom: 8px;
}
.info-panel p {
  font-weight: 300;
  font-size: 0.82rem;
  line-height: 1.6;
  color: rgba(200,215,245,0.75);
}
.mono { font-family: 'JetBrains Mono', monospace; color: #a5b4fc; font-size: 0.82rem; }
.hl { color: var(--pss); font-weight: 500; }
.hl-sss { color: var(--sss); font-weight: 500; }
.hl-pbch { color: var(--pbch); font-weight: 500; }
.hl-dmrs { color: var(--dmrs); font-weight: 500; }

/* â”€â”€ FOOTER â”€â”€ */
.footer {
  text-align: center;
  margin-top: 50px;
  padding-top: 20px;
  border-top: 1px solid rgba(100,150,255,0.06);
}
.footer p {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.68rem;
  color: rgba(100,130,180,0.35);
}

@media (max-width: 768px) {
  .section { padding: 20px 16px; }
  .controls { gap: 8px; }
  .info-row { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="page">

  <div class="hero">
    <h1>5G NR SSB â€” How It Works</h1>
    <div class="tagline">Animated Technical Visualization</div>
    <div class="spec">3GPP TS 38.211 / 38.213 â€” Synchronization Signal Block</div>
  </div>

  <div class="nav-bar">
    <button class="nav-btn active" onclick="scrollTo('#sec-beam')">â‘  Beam Sweeping</button>
    <button class="nav-btn" onclick="scrollTo('#sec-grid')">â‘¡ Resource Grid</button>
    <button class="nav-btn" onclick="scrollTo('#sec-cell')">â‘¢ Cell Search</button>
    <button class="nav-btn" onclick="scrollTo('#sec-burst')">â‘£ Burst Timing</button>
    <button class="nav-btn" onclick="scrollTo('#sec-pbch')">â‘¤ PBCH Decode</button>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- SECTION 1: BEAM SWEEPING ANIMATION    -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section" id="sec-beam">
    <div class="sec-title"><span class="ico">ğŸ“¡</span> SSB Beam Sweeping</div>
    <div class="sec-desc">gNB transmits SSBs sequentially in different beam directions â€” UE detects the strongest beam for initial access</div>
    <div class="canvas-wrap">
      <canvas id="beamCanvas" width="1200" height="520"></canvas>
    </div>
    <div class="controls">
      <button class="btn active" id="beamPlayBtn" onclick="toggleBeamAnim()">â¸ Pause</button>
      <button class="btn" onclick="resetBeamAnim()">â†º Reset</button>
      <div class="speed-control">
        <label>Speed</label>
        <input type="range" class="speed-slider" min="0.3" max="3" step="0.1" value="1" oninput="beamSpeed=this.value">
      </div>
    </div>
    <div class="status-bar" id="beamStatus">
      <span class="label">SSB #0</span> â€” Beam 0 transmitted, sweeping sector coverage area...
    </div>
    <div class="info-row">
      <div class="info-panel">
        <h4>How Beam Sweeping Works</h4>
        <p>The gNB transmits each SSB using a different <span class="hl">analog beam direction</span>. In FR1 (sub-6 GHz), up to <span class="mono">L=8</span> beams sweep within a 5ms half-frame. FR2 (mmWave) uses up to <span class="mono">L=64</span> beams for narrower, higher-gain coverage.</p>
      </div>
      <div class="info-panel">
        <h4>UE Beam Selection</h4>
        <p>The UE measures <span class="hl">SS-RSRP</span> on each detected SSB beam and selects the <span class="hl">strongest SSB index</span> for initial access. This index is reported during RACH via the selected PRACH occasion mapped to that SSB.</p>
      </div>
      <div class="info-panel">
        <h4>Key Parameters</h4>
        <p><span class="mono">ssb-PositionsInBurst</span> â€” bitmap of actually transmitted SSBs<br>
        <span class="mono">ssb-periodicityServingCell</span> â€” {5,10,20,40,80,160} ms<br>
        Default for initial access: <span class="hl">20 ms</span></p>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- SECTION 2: SSB RESOURCE GRID ANIM     -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section" id="sec-grid">
    <div class="sec-title"><span class="ico">â–¦</span> SSB Resource Grid â€” Symbol-by-Symbol Build</div>
    <div class="sec-desc">Watch how the 4 OFDM symbols Ã— 240 subcarriers are populated with PSS, SSS, PBCH, and DMRS</div>
    <div class="canvas-wrap">
      <canvas id="gridCanvas" width="1200" height="580"></canvas>
    </div>
    <div class="controls">
      <button class="btn active" id="gridPlayBtn" onclick="toggleGridAnim()">â¸ Pause</button>
      <button class="btn" onclick="resetGridAnim()">â†º Reset</button>
      <button class="btn" onclick="stepGrid(-1)">â—‚ Prev</button>
      <button class="btn" onclick="stepGrid(1)">Next â–¸</button>
      <div class="speed-control">
        <label>Speed</label>
        <input type="range" class="speed-slider" min="0.3" max="3" step="0.1" value="1" oninput="gridSpeed=this.value">
      </div>
    </div>
    <div class="status-bar" id="gridStatus">
      <span class="label">Building SSB...</span> â€” Watch each signal component fill the resource grid
    </div>
    <div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background:var(--pss)"></div> PSS (127 RE)</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--sss)"></div> SSS (127 RE)</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--pbch)"></div> PBCH (432 RE)</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--dmrs)"></div> DMRS (144 RE)</div>
      <div class="legend-item"><div class="legend-dot" style="background:rgba(100,116,139,0.4)"></div> Guard (unused)</div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- SECTION 3: CELL SEARCH PROCEDURE      -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section" id="sec-cell">
    <div class="sec-title"><span class="ico">ğŸ”</span> Initial Cell Search Procedure</div>
    <div class="sec-desc">Step-by-step animation of how UE discovers and connects to a 5G NR cell using SSB signals</div>
    <div class="canvas-wrap">
      <canvas id="cellCanvas" width="1200" height="500"></canvas>
    </div>
    <div class="controls">
      <button class="btn active" id="cellPlayBtn" onclick="toggleCellAnim()">â¸ Pause</button>
      <button class="btn" onclick="resetCellAnim()">â†º Reset</button>
      <button class="btn" onclick="stepCell(-1)">â—‚ Prev Step</button>
      <button class="btn" onclick="stepCell(1)">Next Step â–¸</button>
    </div>
    <div class="status-bar" id="cellStatus">
      <span class="label">Step 1/5:</span> PSS Detection â€” Correlating m-sequences to find symbol timing...
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- SECTION 4: SSB BURST TIMING           -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section" id="sec-burst">
    <div class="sec-title"><span class="ico">â±</span> SSB Burst Set Timing</div>
    <div class="sec-desc">Visualization of SSB placement within 5ms half-frame and periodicity across radio frames</div>
    <div class="canvas-wrap">
      <canvas id="burstCanvas" width="1200" height="420"></canvas>
    </div>
    <div class="controls">
      <button class="btn active" id="burstPlayBtn" onclick="toggleBurstAnim()">â¸ Pause</button>
      <button class="btn" onclick="resetBurstAnim()">â†º Reset</button>
      <div class="speed-control">
        <label>Speed</label>
        <input type="range" class="speed-slider" min="0.3" max="3" step="0.1" value="1" oninput="burstSpeed=this.value">
      </div>
    </div>
    <div class="status-bar" id="burstStatus">
      <span class="label">Frame 0</span> â€” SSB burst set transmitted in first half-frame...
    </div>
    <div class="info-row">
      <div class="info-panel">
        <h4>SSB Periodicity</h4>
        <p>SSB burst set repeats every <span class="hl">20ms</span> by default during initial access. After connection, the network can configure {5, 10, 20, 40, 80, 160} ms via <span class="mono">ssb-periodicityServingCell</span>.</p>
      </div>
      <div class="info-panel">
        <h4>Case Patterns</h4>
        <p>SSB symbol positions depend on the SCS case:<br>
        <span class="mono">Case A</span> (15kHz): {2,8}+14n<br>
        <span class="mono">Case C</span> (30kHz): {2,8}+14n<br>
        <span class="mono">Case D</span> (120kHz): {4,8,16,20}+28n</p>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- SECTION 5: PBCH DECODE FLOW           -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section" id="sec-pbch">
    <div class="sec-title"><span class="ico">ğŸ“¦</span> PBCH Decoding & MIB Extraction</div>
    <div class="sec-desc">How the UE decodes the Physical Broadcast Channel to extract Master Information Block</div>
    <div class="canvas-wrap">
      <canvas id="pbchCanvas" width="1200" height="480"></canvas>
    </div>
    <div class="controls">
      <button class="btn active" id="pbchPlayBtn" onclick="togglePbchAnim()">â¸ Pause</button>
      <button class="btn" onclick="resetPbchAnim()">â†º Reset</button>
      <button class="btn" onclick="stepPbch(-1)">â—‚ Prev</button>
      <button class="btn" onclick="stepPbch(1)">Next â–¸</button>
    </div>
    <div class="status-bar" id="pbchStatus">
      <span class="label">PBCH Pipeline:</span> DMRS channel estimation â†’ PBCH demodulation â†’ Polar decode â†’ MIB extract
    </div>
  </div>

  <div class="footer">
    <p>5G NR SSB Animated Visualization â€” 3GPP TS 38.211/213/214 Rel-17 &nbsp;|&nbsp; CafeTele Telecom Training &nbsp;|&nbsp; www.cafetele.com</p>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILITY FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const C = {
  pss: '#38bdf8', pssG: 'rgba(56,189,248,', 
  sss: '#a78bfa', sssG: 'rgba(167,139,250,',
  pbch: '#34d399', pbchG: 'rgba(52,211,153,',
  dmrs: '#fbbf24', dmrsG: 'rgba(251,191,36,',
  guard: 'rgba(100,116,139,0.25)',
  bg: '#080d1a', cardBg: '#0c1228',
  text: '#93c5fd', textDim: 'rgba(147,197,253,0.4)',
  grid: 'rgba(100,150,255,0.06)',
  white: 'rgba(224,242,254,0.9)',
};

function setupCanvas(id) {
  const c = document.getElementById(id);
  const ctx = c.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = c.getBoundingClientRect();
  const w = c.width; const h = c.height;
  c.width = w * dpr; c.height = h * dpr;
  c.style.width = w + 'px'; c.style.height = h + 'px';
  ctx.scale(dpr, dpr);
  return { ctx, w, h, c };
}

function drawRoundRect(ctx, x, y, w, h, r, fill, stroke) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  if (fill) { ctx.fillStyle = fill; ctx.fill(); }
  if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 1; ctx.stroke(); }
}

function drawGlassRect(ctx, x, y, w, h, r, baseColor, alpha) {
  const a = alpha || 0.35;
  drawRoundRect(ctx, x, y, w, h, r, baseColor + a + ')', baseColor + '0.5)');
  // Shine
  const grad = ctx.createLinearGradient(x, y, x, y + h * 0.4);
  grad.addColorStop(0, baseColor + '0.25)');
  grad.addColorStop(1, baseColor + '0)');
  drawRoundRect(ctx, x, y, w, h * 0.4, r, grad, null);
}

function lerpColor(t) {
  const r = Math.round(56 + t * (167 - 56));
  const g = Math.round(189 + t * (139 - 189));
  const b = Math.round(248 + t * (250 - 248));
  return `rgb(${r},${g},${b})`;
}

function ease(t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }
function easeOut(t) { return 1 - Math.pow(1 - t, 3); }

function scrollTo(sel) {
  document.querySelector(sel)?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMATION 1: BEAM SWEEPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let beamPlaying = true, beamSpeed = 1, beamTime = 0;
const BEAM = setupCanvas('beamCanvas');
const beamColors = [
  C.pssG, 'rgba(79,155,243,', 'rgba(99,130,241,', C.sssG,
  C.pbchG, 'rgba(45,212,191,', C.dmrsG, 'rgba(251,146,60,'
];
const beamNames = ['SSB #0','SSB #1','SSB #2','SSB #3','SSB #4','SSB #5','SSB #6','SSB #7'];

function drawBeamFrame(t) {
  const { ctx, w, h } = BEAM;
  ctx.clearRect(0, 0, w, h);

  // Background
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, w, h);

  const cx = 160, cy = h / 2;
  const totalCycle = 8000; // ms per full sweep
  const phase = (t % totalCycle) / totalCycle;
  const activeBeam = Math.floor(phase * 8);
  const beamPhase = (phase * 8) % 1;

  // Draw gNB tower
  ctx.save();
  // Tower base
  drawRoundRect(ctx, cx - 25, cy - 80, 50, 160, 6, 'rgba(30,50,90,0.6)', 'rgba(100,150,255,0.2)');
  // Antenna panels
  for (let i = -1; i <= 1; i++) {
    drawRoundRect(ctx, cx - 10 + i * 4, cy - 90, 12, 25, 3, 'rgba(56,189,248,0.3)', 'rgba(56,189,248,0.5)');
  }
  // gNB label
  ctx.font = '600 14px Outfit';
  ctx.fillStyle = C.white;
  ctx.textAlign = 'center';
  ctx.fillText('gNB', cx, cy + 110);
  ctx.font = '300 10px "JetBrains Mono"';
  ctx.fillStyle = C.textDim;
  ctx.fillText('5G Base Station', cx, cy + 126);
  ctx.restore();

  // Draw 8 beam sectors
  const startAngle = -Math.PI * 0.55;
  const totalSpan = Math.PI * 1.1;
  const beamWidth = totalSpan / 8;
  const maxRadius = 520;

  for (let i = 0; i < 8; i++) {
    const angle = startAngle + i * beamWidth + beamWidth / 2;
    const isActive = i === activeBeam;
    const alpha = isActive ? 0.15 + 0.15 * Math.sin(beamPhase * Math.PI) : 0.03;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, maxRadius, startAngle + i * beamWidth, startAngle + (i + 1) * beamWidth);
    ctx.closePath();

    const grad = ctx.createRadialGradient(cx, cy, 30, cx, cy, maxRadius);
    grad.addColorStop(0, beamColors[i] + (isActive ? '0.5)' : '0.1)'));
    grad.addColorStop(0.5, beamColors[i] + alpha + ')');
    grad.addColorStop(1, beamColors[i] + '0)');
    ctx.fillStyle = grad;
    ctx.fill();

    // Beam boundary lines
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    const bx = cx + Math.cos(startAngle + i * beamWidth) * maxRadius;
    const by = cy + Math.sin(startAngle + i * beamWidth) * maxRadius;
    ctx.lineTo(bx, by);
    ctx.strokeStyle = beamColors[i] + '0.15)';
    ctx.lineWidth = 0.5;
    ctx.stroke();

    // Beam label
    const lx = cx + Math.cos(angle) * (isActive ? 280 : 240);
    const ly = cy + Math.sin(angle) * (isActive ? 280 : 240);
    ctx.font = isActive ? '600 13px Outfit' : '400 10px Outfit';
    ctx.fillStyle = beamColors[i] + (isActive ? '0.95)' : '0.45)');
    ctx.textAlign = 'center';
    ctx.fillText(beamNames[i], lx, ly);

    // Active beam pulse rings
    if (isActive) {
      for (let r = 0; r < 3; r++) {
        const rPhase = (beamPhase + r * 0.3) % 1;
        const radius = 50 + rPhase * 280;
        const rAlpha = (1 - rPhase) * 0.3;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, startAngle + i * beamWidth + 0.02, startAngle + (i + 1) * beamWidth - 0.02);
        ctx.strokeStyle = beamColors[i] + rAlpha + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // Draw UE devices at various positions
  const ues = [
    { x: 580, y: 120, beam: 1, label: 'UE-1' },
    { x: 750, y: 250, beam: 3, label: 'UE-2' },
    { x: 650, y: 400, beam: 5, label: 'UE-3' },
    { x: 900, y: 180, beam: 2, label: 'UE-4' },
  ];

  ues.forEach(ue => {
    const isServed = ue.beam === activeBeam;
    // UE icon
    drawRoundRect(ctx, ue.x - 14, ue.y - 18, 28, 36, 5,
      isServed ? 'rgba(56,189,248,0.25)' : 'rgba(40,50,80,0.5)',
      isServed ? 'rgba(56,189,248,0.6)' : 'rgba(100,150,255,0.15)');
    
    // Screen
    drawRoundRect(ctx, ue.x - 9, ue.y - 13, 18, 20, 2,
      isServed ? 'rgba(56,189,248,0.15)' : 'rgba(20,30,50,0.5)', null);

    ctx.font = '500 9px "JetBrains Mono"';
    ctx.textAlign = 'center';
    ctx.fillStyle = isServed ? C.pss : C.textDim;
    ctx.fillText(ue.label, ue.x, ue.y + 32);

    if (isServed) {
      // Signal reception indicator
      const pulse = Math.sin(t / 200) * 0.3 + 0.7;
      ctx.beginPath();
      ctx.arc(ue.x, ue.y, 22, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(56,189,248,${pulse * 0.4})`;
      ctx.lineWidth = 2;
      ctx.stroke();

      // RSRP bar
      ctx.font = '500 8px "JetBrains Mono"';
      ctx.fillStyle = 'rgba(56,189,248,0.7)';
      ctx.fillText('â–² SS-RSRP', ue.x, ue.y + 44);
    }
  });

  // Info box top-right
  drawRoundRect(ctx, w - 290, 16, 272, 100, 10, 'rgba(12,18,40,0.85)', 'rgba(100,150,255,0.12)');
  ctx.font = '600 12px Outfit';
  ctx.fillStyle = C.text;
  ctx.textAlign = 'left';
  ctx.fillText('SSB Beam Sweep Status', w - 274, 38);
  ctx.font = '400 11px "JetBrains Mono"';
  ctx.fillStyle = beamColors[activeBeam] + '0.9)';
  ctx.fillText(`Active: ${beamNames[activeBeam]}`, w - 274, 58);
  ctx.fillStyle = C.textDim;
  ctx.font = '300 10px "JetBrains Mono"';
  ctx.fillText(`Beam Index: ${activeBeam}  |  L_max = 8`, w - 274, 76);
  ctx.fillText(`Period: 20ms  |  FR1 (Sub-6 GHz)`, w - 274, 92);
  ctx.fillText(`Half-frame: 5ms burst window`, w - 274, 106);

  // Update status
  document.getElementById('beamStatus').innerHTML =
    `<span class="label">${beamNames[activeBeam]}</span> â€” Beam ${activeBeam} active, direction ${(activeBeam * 22.5 - 90).toFixed(0)}Â° â€” UEs measure SS-RSRP for beam selection`;
}

let beamRAF;
function animateBeam(ts) {
  if (beamPlaying) beamTime += 16 * beamSpeed;
  drawBeamFrame(beamTime);
  beamRAF = requestAnimationFrame(animateBeam);
}
function toggleBeamAnim() {
  beamPlaying = !beamPlaying;
  document.getElementById('beamPlayBtn').textContent = beamPlaying ? 'â¸ Pause' : 'â–¶ Play';
  document.getElementById('beamPlayBtn').classList.toggle('active', beamPlaying);
}
function resetBeamAnim() { beamTime = 0; }


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMATION 2: RESOURCE GRID BUILD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gridPlaying = true, gridSpeed = 1, gridTime = 0, gridStep = 0;
const GRID = setupCanvas('gridCanvas');

const gridPhases = [
  { name: 'Symbol 0 â€” PSS', dur: 2500, desc: 'PSS mapped to center 127 subcarriers (k=56â†’182) of Symbol 0. Guard bands of 56/57 SCs remain unused.' },
  { name: 'Symbol 1 â€” PBCH + DMRS', dur: 3000, desc: 'PBCH spans all 240 subcarriers in Symbol 1. DMRS interleaved every 4th RE for channel estimation.' },
  { name: 'Symbol 2 â€” SSS', dur: 2500, desc: 'SSS occupies center 127 subcarriers of Symbol 2 (same position as PSS). Guard bands preserved.' },
  { name: 'Symbol 3 â€” PBCH + DMRS', dur: 3000, desc: 'Final PBCH+DMRS symbol completes the SSB block. Total: 4 symbols Ã— 240 subcarriers.' },
  { name: 'Complete SSB', dur: 3000, desc: 'Full SSB: PSS (127 RE) + SSS (127 RE) + PBCH (432 RE) + DMRS (144 RE) = 20 RBs Ã— 4 symbols.' },
];

function drawGridFrame(t) {
  const { ctx, w, h } = GRID;
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, w, h);

  // Calculate current phase
  let elapsed = 0;
  let currentPhase = 0;
  let phaseT = 0;
  for (let i = 0; i < gridPhases.length; i++) {
    if (t < elapsed + gridPhases[i].dur) {
      currentPhase = i;
      phaseT = (t - elapsed) / gridPhases[i].dur;
      break;
    }
    elapsed += gridPhases[i].dur;
    if (i === gridPhases.length - 1) { currentPhase = i; phaseT = 1; }
  }
  gridStep = currentPhase;

  const gx = 120, gy = 50;
  const gw = 900, gh = 440;
  const symW = gw / 4;
  const cellH = gh / 20; // 20 rows representing subcarrier groups

  // Grid background
  drawRoundRect(ctx, gx - 2, gy - 2, gw + 4, gh + 4, 8, 'rgba(8,14,30,0.8)', 'rgba(100,150,255,0.1)');

  // Grid lines
  ctx.strokeStyle = C.grid;
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    ctx.beginPath();
    ctx.moveTo(gx + i * symW, gy);
    ctx.lineTo(gx + i * symW, gy + gh);
    ctx.stroke();
  }
  for (let i = 0; i <= 20; i++) {
    ctx.beginPath();
    ctx.moveTo(gx, gy + i * cellH);
    ctx.lineTo(gx + gw, gy + i * cellH);
    ctx.stroke();
  }

  // Column headers
  ctx.font = '500 11px "JetBrains Mono"';
  ctx.textAlign = 'center';
  const symLabels = ['Symbol 0', 'Symbol 1', 'Symbol 2', 'Symbol 3'];
  for (let i = 0; i < 4; i++) {
    ctx.fillStyle = (currentPhase === i || currentPhase === 4) ? C.text : C.textDim;
    ctx.fillText(symLabels[i], gx + i * symW + symW / 2, gy - 10);
  }

  // Row labels
  ctx.font = '300 9px "JetBrains Mono"';
  ctx.textAlign = 'right';
  const rowLabels = ['k=239','','','k=183','','','k=182','','','k=128','k=127','','','k=56','','','k=55','','','k=0'];
  for (let i = 0; i < 20; i++) {
    if (rowLabels[i]) {
      ctx.fillStyle = C.textDim;
      ctx.fillText(rowLabels[i], gx - 8, gy + i * cellH + cellH / 2 + 3);
    }
  }

  // Y-axis label
  ctx.save();
  ctx.translate(25, gy + gh / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = '400 11px Outfit';
  ctx.fillStyle = 'rgba(147,197,253,0.35)';
  ctx.textAlign = 'center';
  ctx.fillText('Frequency (Subcarriers) â†‘', 0, 0);
  ctx.restore();

  // X-axis label
  ctx.font = '400 11px Outfit';
  ctx.fillStyle = 'rgba(147,197,253,0.35)';
  ctx.textAlign = 'center';
  ctx.fillText('Time (OFDM Symbols) â†’', gx + gw / 2, gy + gh + 30);

  // â”€â”€ Draw filled cells â”€â”€
  function fillCell(sym, rowStart, rowEnd, color, colorG, alpha, anim) {
    const a = anim !== undefined ? anim : 1;
    if (a <= 0) return;
    const x = gx + sym * symW + 2;
    const y1 = gy + rowStart * cellH + 1;
    const h1 = (rowEnd - rowStart) * cellH - 2;
    const finalAlpha = 0.35 * a;

    ctx.save();
    ctx.globalAlpha = a;
    drawRoundRect(ctx, x, y1, symW - 4, h1, 5, colorG + finalAlpha + ')', colorG + (0.5 * a) + ')');
    // Shine
    const grad = ctx.createLinearGradient(x, y1, x, y1 + h1 * 0.3);
    grad.addColorStop(0, colorG + (0.2 * a) + ')');
    grad.addColorStop(1, colorG + '0)');
    drawRoundRect(ctx, x, y1, symW - 4, h1 * 0.35, 5, grad, null);
    // Glow
    ctx.shadowColor = color;
    ctx.shadowBlur = 15 * a;
    drawRoundRect(ctx, x + 4, y1 + 4, symW - 12, h1 - 8, 4, 'rgba(0,0,0,0)', null);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function fillLabel(sym, row, text, color, anim) {
    if (anim <= 0) return;
    ctx.save();
    ctx.globalAlpha = anim;
    ctx.font = '600 15px Outfit';
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.fillText(text, gx + sym * symW + symW / 2, gy + row * cellH);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function fillSubLabel(sym, row, text, colorG, anim) {
    if (anim <= 0) return;
    ctx.save();
    ctx.globalAlpha = anim * 0.7;
    ctx.font = '400 9px "JetBrains Mono"';
    ctx.fillStyle = colorG + '0.8)';
    ctx.textAlign = 'center';
    ctx.fillText(text, gx + sym * symW + symW / 2, gy + row * cellH);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  const pt = ease(Math.min(phaseT * 1.5, 1));

  // Phase 0: PSS in Symbol 0
  const p0 = currentPhase > 0 ? 1 : pt;
  // Guard top (rows 0-3)
  fillCell(0, 0, 3, '#64748b', 'rgba(100,116,139,', 0.12, p0);
  // PSS (rows 3-17 = center 127 SCs)
  fillCell(0, 3, 17, C.pss, C.pssG, 0.35, p0);
  fillLabel(0, 11, 'PSS', 'rgba(224,242,254,' + p0 + ')', p0);
  fillSubLabel(0, 12.5, '127 REs (m-seq)', C.pssG, p0);
  fillSubLabel(0, 13.8, 'N_ID^(2) âˆˆ {0,1,2}', C.pssG, p0);
  // Guard bottom (rows 17-20)
  fillCell(0, 17, 20, '#64748b', 'rgba(100,116,139,', 0.12, p0);

  // Phase 1: PBCH+DMRS in Symbol 1
  if (currentPhase >= 1) {
    const p1 = currentPhase > 1 ? 1 : pt;
    // PBCH upper (rows 0-3)
    fillCell(1, 0, 3, C.pbch, C.pbchG, 0.3, p1);
    // PBCH middle-upper (rows 3-6)
    fillCell(1, 3, 6, C.pbch, C.pbchG, 0.3, p1);
    // DMRS center (rows 6-14) - interleaved with PBCH
    fillCell(1, 6, 14, C.dmrs, C.dmrsG, 0.3, p1);
    fillLabel(1, 10.5, 'PBCH', 'rgba(167,243,208,' + p1 + ')', p1);
    fillSubLabel(1, 12, '+ DMRS', C.dmrsG, p1);
    fillSubLabel(1, 13.3, 'All 240 subcarriers', C.pbchG, p1);
    // PBCH lower (rows 14-17)
    fillCell(1, 14, 17, C.pbch, C.pbchG, 0.3, p1);
    // PBCH bottom (rows 17-20)
    fillCell(1, 17, 20, C.pbch, C.pbchG, 0.3, p1);

    // DMRS stripe indicators
    for (let r = 0; r < 20; r++) {
      if (r % 4 === 0) {
        ctx.save();
        ctx.globalAlpha = p1 * 0.6;
        ctx.fillStyle = C.dmrs;
        const sx = gx + 1 * symW + symW - 10;
        const sy = gy + r * cellH + cellH / 2 - 2;
        ctx.fillRect(sx, sy, 6, 4);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
    }
  }

  // Phase 2: SSS in Symbol 2
  if (currentPhase >= 2) {
    const p2 = currentPhase > 2 ? 1 : pt;
    fillCell(2, 0, 3, '#64748b', 'rgba(100,116,139,', 0.12, p2);
    fillCell(2, 3, 17, C.sss, C.sssG, 0.35, p2);
    fillLabel(2, 11, 'SSS', 'rgba(237,233,254,' + p2 + ')', p2);
    fillSubLabel(2, 12.5, '127 REs (Gold seq)', C.sssG, p2);
    fillSubLabel(2, 13.8, 'N_ID^(1) âˆˆ {0..335}', C.sssG, p2);
    fillCell(2, 17, 20, '#64748b', 'rgba(100,116,139,', 0.12, p2);
  }

  // Phase 3: PBCH+DMRS in Symbol 3
  if (currentPhase >= 3) {
    const p3 = currentPhase > 3 ? 1 : pt;
    fillCell(3, 0, 3, C.pbch, C.pbchG, 0.3, p3);
    fillCell(3, 3, 6, C.pbch, C.pbchG, 0.3, p3);
    fillCell(3, 6, 14, C.dmrs, C.dmrsG, 0.3, p3);
    fillLabel(3, 10.5, 'PBCH', 'rgba(167,243,208,' + p3 + ')', p3);
    fillSubLabel(3, 12, '+ DMRS', C.dmrsG, p3);
    fillSubLabel(3, 13.3, 'All 240 subcarriers', C.pbchG, p3);
    fillCell(3, 14, 17, C.pbch, C.pbchG, 0.3, p3);
    fillCell(3, 17, 20, C.pbch, C.pbchG, 0.3, p3);
    for (let r = 0; r < 20; r++) {
      if (r % 4 === 0) {
        ctx.save();
        ctx.globalAlpha = p3 * 0.6;
        ctx.fillStyle = C.dmrs;
        ctx.fillRect(gx + 3 * symW + symW - 10, gy + r * cellH + cellH / 2 - 2, 6, 4);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
    }
  }

  // Phase 4 highlight: pulse all
  if (currentPhase === 4) {
    const pulse = Math.sin(t / 400) * 0.08 + 0.08;
    ctx.save();
    ctx.globalAlpha = pulse;
    drawRoundRect(ctx, gx - 2, gy - 2, gw + 4, gh + 4, 8, null, C.pss);
    ctx.lineWidth = 2;
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Right side info panel
  const panelX = gx + gw + 30;
  drawRoundRect(ctx, panelX, gy, 140, gh, 10, 'rgba(12,18,40,0.7)', 'rgba(100,150,255,0.08)');
  ctx.font = '600 10px "JetBrains Mono"';
  ctx.fillStyle = C.text;
  ctx.textAlign = 'left';
  ctx.fillText('RE Count', panelX + 12, gy + 24);

  const counts = [
    { label: 'PSS', val: '127', color: C.pss, phase: 0 },
    { label: 'SSS', val: '127', color: C.sss, phase: 2 },
    { label: 'PBCH', val: '432', color: C.pbch, phase: 1 },
    { label: 'DMRS', val: '144', color: C.dmrs, phase: 1 },
    { label: 'Guard', val: '226', color: '#64748b', phase: 0 },
  ];

  counts.forEach((c, i) => {
    const cy = gy + 50 + i * 44;
    const shown = currentPhase >= c.phase;
    ctx.globalAlpha = shown ? 1 : 0.2;
    ctx.fillStyle = c.color;
    ctx.font = '600 11px "JetBrains Mono"';
    ctx.fillText(c.label, panelX + 12, cy);
    ctx.font = '300 18px Outfit';
    ctx.fillText(c.val, panelX + 12, cy + 22);
    ctx.globalAlpha = 1;
  });

  // Total
  if (currentPhase === 4) {
    ctx.font = '500 10px "JetBrains Mono"';
    ctx.fillStyle = C.text;
    ctx.fillText('â”€â”€â”€â”€â”€â”€â”€â”€â”€', panelX + 12, gy + 290);
    ctx.font = '300 10px Outfit';
    ctx.fillStyle = C.white;
    ctx.fillText('Total: 960 RE', panelX + 12, gy + 308);
    ctx.fillText('= 20 RBs Ã— 4 sym', panelX + 12, gy + 324);
  }

  // Update status
  document.getElementById('gridStatus').innerHTML =
    `<span class="label">${gridPhases[currentPhase].name}</span> â€” ${gridPhases[currentPhase].desc}`;
}

let gridRAF;
const gridTotalDur = gridPhases.reduce((s, p) => s + p.dur, 0);
function animateGrid(ts) {
  if (gridPlaying) gridTime += 16 * gridSpeed;
  if (gridTime > gridTotalDur) gridTime = gridTotalDur; // stop at end
  drawGridFrame(gridTime);
  gridRAF = requestAnimationFrame(animateGrid);
}
function toggleGridAnim() {
  gridPlaying = !gridPlaying;
  document.getElementById('gridPlayBtn').textContent = gridPlaying ? 'â¸ Pause' : 'â–¶ Play';
  document.getElementById('gridPlayBtn').classList.toggle('active', gridPlaying);
}
function resetGridAnim() { gridTime = 0; gridPlaying = true; toggleGridAnim(); toggleGridAnim(); }
function stepGrid(dir) {
  gridPlaying = false;
  document.getElementById('gridPlayBtn').textContent = 'â–¶ Play';
  document.getElementById('gridPlayBtn').classList.remove('active');
  let target = gridStep + dir;
  target = Math.max(0, Math.min(gridPhases.length - 1, target));
  let t = 0;
  for (let i = 0; i < target; i++) t += gridPhases[i].dur;
  t += gridPhases[target].dur * 0.8;
  gridTime = t;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMATION 3: CELL SEARCH PROCEDURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let cellPlaying = true, cellTime = 0, cellStep = 0;
const CELL = setupCanvas('cellCanvas');

const cellSteps = [
  { name: 'PSS Detection', dur: 3500, color: C.pss, colorG: C.pssG,
    detail: ['Correlate 3 m-sequences', 'Find symbol boundary', 'Determine N_ID^(2) âˆˆ {0,1,2}', 'Coarse freq offset estimated'] },
  { name: 'SSS Detection', dur: 3500, color: C.sss, colorG: C.sssG,
    detail: ['Correlate 336 Gold sequences', 'Determine N_ID^(1) âˆˆ {0..335}', 'Compute PCI: 3Ã—N_ID^(1)+N_ID^(2)', 'Fine freq offset correction'] },
  { name: 'PBCH DMRS', dur: 3000, color: C.dmrs, colorG: C.dmrsG,
    detail: ['Extract DMRS from every 4th RE', 'Channel estimation H(f)', 'Get SSB index (3 LSBs)', 'Timing: v = N_ID^cell mod 4'] },
  { name: 'PBCH Decode', dur: 3500, color: C.pbch, colorG: C.pbchG,
    detail: ['QPSK demodulation', 'Polar decode + CRC-24C check', 'Extract MIB (24 bits)', 'SFN, CORESET#0, k_SSB, barred'] },
  { name: 'SIB1 â†’ RACH', dur: 3500, color: '#60a5fa', colorG: 'rgba(96,165,250,',
    detail: ['CORESET#0 â†’ read PDCCH', 'DCI â†’ schedule SIB1 on PDSCH', 'SIB1: RACH config, BWP, timing', 'Initiate Random Access (Msg1)'] },
];

function drawCellFrame(t) {
  const { ctx, w, h } = CELL;
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, w, h);

  let elapsed = 0;
  let current = 0;
  let pt = 0;
  for (let i = 0; i < cellSteps.length; i++) {
    if (t < elapsed + cellSteps[i].dur) {
      current = i;
      pt = (t - elapsed) / cellSteps[i].dur;
      break;
    }
    elapsed += cellSteps[i].dur;
    if (i === cellSteps.length - 1) { current = i; pt = 1; }
  }
  cellStep = current;
  const step = cellSteps[current];

  // â”€â”€ Pipeline visualization â”€â”€
  const pipeY = 60;
  const pipeH = 70;
  const stepW = (w - 120) / 5;
  const startX = 60;

  for (let i = 0; i < 5; i++) {
    const sx = startX + i * stepW;
    const isActive = i === current;
    const isDone = i < current;
    const s = cellSteps[i];

    const alpha = isActive ? 0.4 : isDone ? 0.25 : 0.06;
    drawRoundRect(ctx, sx + 4, pipeY, stepW - 8, pipeH, 10,
      s.colorG + alpha + ')',
      s.colorG + (isActive ? '0.6)' : isDone ? '0.3)' : '0.1)'));

    if (isActive) {
      // Progress bar inside
      const barW = (stepW - 16) * ease(pt);
      drawRoundRect(ctx, sx + 8, pipeY + pipeH - 8, barW, 4, 2, s.colorG + '0.5)', null);
      
      // Pulse
      const pulse = Math.sin(t / 250) * 0.15 + 0.15;
      ctx.save();
      ctx.shadowColor = s.color;
      ctx.shadowBlur = 20;
      drawRoundRect(ctx, sx + 4, pipeY, stepW - 8, pipeH, 10, s.colorG + pulse + ')', null);
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // Step number
    ctx.font = '700 11px "JetBrains Mono"';
    ctx.textAlign = 'center';
    ctx.fillStyle = isDone ? s.color : isActive ? s.color : C.textDim;
    ctx.fillText(`Step ${i + 1}`, sx + stepW / 2, pipeY + 22);

    // Step name
    ctx.font = isActive ? '600 11px Outfit' : '400 10px Outfit';
    ctx.fillText(s.name, sx + stepW / 2, pipeY + 40);

    // Checkmark for done
    if (isDone) {
      ctx.font = '600 14px Outfit';
      ctx.fillStyle = s.color;
      ctx.fillText('âœ“', sx + stepW / 2, pipeY + 58);
    }

    // Arrow between steps
    if (i < 4) {
      const ax = sx + stepW;
      ctx.beginPath();
      ctx.moveTo(ax - 4, pipeY + pipeH / 2 - 4);
      ctx.lineTo(ax + 4, pipeY + pipeH / 2);
      ctx.lineTo(ax - 4, pipeY + pipeH / 2 + 4);
      ctx.fillStyle = i < current ? 'rgba(147,197,253,0.4)' : 'rgba(147,197,253,0.1)';
      ctx.fill();
    }
  }

  // â”€â”€ Detail panel for active step â”€â”€
  const detY = 170;
  const detH = 280;
  drawRoundRect(ctx, 60, detY, w - 120, detH, 14, 'rgba(10,16,35,0.7)', step.colorG + '0.15)');

  // Header
  ctx.font = '700 22px Outfit';
  ctx.textAlign = 'left';
  ctx.fillStyle = step.color;
  ctx.fillText(step.name, 95, detY + 40);

  ctx.font = '300 12px "JetBrains Mono"';
  ctx.fillStyle = step.colorG + '0.5)';
  ctx.fillText(`Step ${current + 1} of 5`, 95, detY + 60);

  // Detail items with animation
  step.detail.forEach((line, i) => {
    const itemDelay = i * 0.15;
    const itemT = Math.max(0, Math.min(1, (pt - itemDelay) / 0.4));
    if (itemT <= 0) return;

    const iy = detY + 90 + i * 45;
    const ix = 95 + (1 - easeOut(itemT)) * 30;

    ctx.save();
    ctx.globalAlpha = easeOut(itemT);

    // Bullet
    drawRoundRect(ctx, ix, iy - 6, 8, 8, 2, step.colorG + '0.4)', null);

    // Text
    ctx.font = '400 13px Outfit';
    ctx.fillStyle = C.white;
    ctx.fillText(line, ix + 20, iy + 2);

    // Animated check on complete
    if (pt > 0.8) {
      ctx.font = '500 12px Outfit';
      ctx.fillStyle = step.colorG + '0.6)';
      ctx.fillText('â—', ix + ctx.measureText(line).width + 28, iy + 2);
    }

    ctx.globalAlpha = 1;
    ctx.restore();
  });

  // â”€â”€ Signal visualization on the right â”€â”€
  const sigX = w - 370;
  const sigY = detY + 30;
  const sigW = 290;
  const sigH = 230;

  drawRoundRect(ctx, sigX, sigY, sigW, sigH, 10, 'rgba(6,10,20,0.6)', 'rgba(100,150,255,0.06)');

  // Draw signal waveform based on step
  ctx.save();
  ctx.beginPath();
  ctx.rect(sigX + 5, sigY + 30, sigW - 10, sigH - 60);
  ctx.clip();

  const waveCx = sigX + sigW / 2;
  const waveCy = sigY + sigH / 2 + 10;

  if (current === 0) {
    // PSS m-sequence correlation
    ctx.font = '500 9px "JetBrains Mono"';
    ctx.fillStyle = C.textDim;
    ctx.textAlign = 'center';
    ctx.fillText('PSS Correlation Output', waveCx, sigY + 22);

    for (let x = 0; x < sigW - 20; x++) {
      const nx = x / (sigW - 20);
      const noise = Math.sin(x * 0.5 + t * 0.003) * 8 + Math.sin(x * 1.3) * 4;
      const peak = Math.exp(-Math.pow((nx - 0.5) * 8, 2)) * 80 * ease(Math.min(pt * 2, 1));
      const y = waveCy - noise - peak;
      ctx.fillStyle = peak > 20 ? C.pss : step.colorG + '0.3)';
      ctx.fillRect(sigX + 10 + x, y, 1.5, 2);
    }
    // Peak label
    if (pt > 0.3) {
      ctx.beginPath();
      ctx.moveTo(waveCx, waveCy - 85);
      ctx.lineTo(waveCx, waveCy - 60);
      ctx.strokeStyle = C.pss;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = '500 9px "JetBrains Mono"';
      ctx.fillStyle = C.pss;
      ctx.fillText('â–¼ Peak â†’ Timing', waveCx, waveCy - 90);
    }
  } else if (current === 1) {
    // SSS Gold sequence
    ctx.font = '500 9px "JetBrains Mono"';
    ctx.fillStyle = C.textDim;
    ctx.textAlign = 'center';
    ctx.fillText('SSS Correlation (336 hypotheses)', waveCx, sigY + 22);

    for (let h = 0; h < 30; h++) {
      const barX = sigX + 20 + h * 8.5;
      const barH = (Math.sin(h * 0.8 + 2) + 1) * 20 + 5;
      const isMatch = h === 17;
      const matchH = isMatch ? barH + 55 * ease(Math.min(pt * 2, 1)) : barH;
      drawRoundRect(ctx, barX, waveCy + 40 - matchH, 6, matchH, 2,
        isMatch ? C.sss : step.colorG + '0.2)', null);
    }
    if (pt > 0.4) {
      ctx.font = '500 9px "JetBrains Mono"';
      ctx.fillStyle = C.sss;
      ctx.fillText('N_ID^(1) = 17 matched', waveCx, waveCy + 55);
    }
  } else if (current === 2) {
    // DMRS channel estimation
    ctx.font = '500 9px "JetBrains Mono"';
    ctx.fillStyle = C.textDim;
    ctx.textAlign = 'center';
    ctx.fillText('Channel Estimate H(f)', waveCx, sigY + 22);

    ctx.beginPath();
    for (let x = 0; x < sigW - 20; x++) {
      const nx = x / (sigW - 20);
      const ch = Math.sin(nx * 6 + 1) * 30 + Math.sin(nx * 12) * 10;
      const y = waveCy - ch * ease(Math.min(pt * 1.5, 1));
      if (x === 0) ctx.moveTo(sigX + 10 + x, y);
      else ctx.lineTo(sigX + 10 + x, y);
    }
    ctx.strokeStyle = C.dmrs;
    ctx.lineWidth = 2;
    ctx.stroke();

    // DMRS pilot dots
    for (let d = 0; d < 12; d++) {
      const dx = sigX + 20 + d * 22;
      const nx = (d * 22) / (sigW - 20);
      const ch = Math.sin(nx * 6 + 1) * 30 + Math.sin(nx * 12) * 10;
      const dy = waveCy - ch * ease(Math.min(pt * 1.5, 1));
      ctx.beginPath();
      ctx.arc(dx, dy, 4, 0, Math.PI * 2);
      ctx.fillStyle = C.dmrs;
      ctx.fill();
    }
  } else if (current === 3) {
    // PBCH constellation
    ctx.font = '500 9px "JetBrains Mono"';
    ctx.fillStyle = C.textDim;
    ctx.textAlign = 'center';
    ctx.fillText('QPSK Constellation (PBCH)', waveCx, sigY + 22);

    // Axes
    ctx.strokeStyle = 'rgba(100,150,255,0.1)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(waveCx, sigY + 40);
    ctx.lineTo(waveCx, sigY + sigH - 20);
    ctx.moveTo(sigX + 20, waveCy);
    ctx.lineTo(sigX + sigW - 20, waveCy);
    ctx.stroke();

    // QPSK points
    const qpsk = [[1,1],[-1,1],[-1,-1],[1,-1]];
    const spread = 55;
    const numPts = Math.floor(ease(Math.min(pt * 1.5, 1)) * 60);
    for (let p = 0; p < numPts; p++) {
      const qi = p % 4;
      const noise = 6;
      const px = waveCx + qpsk[qi][0] * spread + (Math.random() - 0.5) * noise;
      const py = waveCy - qpsk[qi][1] * spread + (Math.random() - 0.5) * noise;
      ctx.beginPath();
      ctx.arc(px, py, 2.5, 0, Math.PI * 2);
      ctx.fillStyle = C.pbchG + '0.6)';
      ctx.fill();
    }
    // Ideal points
    qpsk.forEach(q => {
      ctx.beginPath();
      ctx.arc(waveCx + q[0] * spread, waveCy - q[1] * spread, 6, 0, Math.PI * 2);
      ctx.strokeStyle = C.pbch;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    });
  } else {
    // SIB1 â†’ RACH flow
    ctx.font = '500 9px "JetBrains Mono"';
    ctx.fillStyle = C.textDim;
    ctx.textAlign = 'center';
    ctx.fillText('Initial Access Flow', waveCx, sigY + 22);

    const boxes = ['MIB', 'CORESET#0', 'SIB1', 'RACH'];
    const boxColors = [C.pbch, C.pss, C.sss, '#60a5fa'];
    boxes.forEach((b, i) => {
      const bx = sigX + 30 + i * 65;
      const by = waveCy - 15;
      const show = ease(Math.min((pt - i * 0.15) / 0.4, 1));
      if (show <= 0) return;
      ctx.save();
      ctx.globalAlpha = show;
      drawRoundRect(ctx, bx, by, 55, 30, 6, boxColors[i], null);
      ctx.font = '600 10px "JetBrains Mono"';
      ctx.fillStyle = '#0a0e1a';
      ctx.textAlign = 'center';
      ctx.fillText(b, bx + 27, by + 19);
      if (i < 3) {
        ctx.beginPath();
        ctx.moveTo(bx + 55, by + 15);
        ctx.lineTo(bx + 65, by + 15);
        ctx.strokeStyle = 'rgba(147,197,253,0.4)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    });
  }

  ctx.restore();

  // PCI display
  if (current >= 1) {
    drawRoundRect(ctx, 95, detY + detH - 55, 350, 38, 8, 'rgba(10,16,35,0.6)', 'rgba(100,150,255,0.08)');
    ctx.font = '500 12px "JetBrains Mono"';
    ctx.textAlign = 'left';
    ctx.fillStyle = C.text;
    ctx.fillText('PCI = 3 Ã— 17 + 1 = 52', 112, detY + detH - 30);
    ctx.font = '300 10px "JetBrains Mono"';
    ctx.fillStyle = C.textDim;
    ctx.fillText('N_ID^(1)=17, N_ID^(2)=1', 310, detY + detH - 30);
  }

  document.getElementById('cellStatus').innerHTML =
    `<span class="label">Step ${current + 1}/5: ${step.name}</span> â€” ${step.detail[Math.min(Math.floor(pt * step.detail.length), step.detail.length - 1)]}`;
}

const cellTotalDur = cellSteps.reduce((s, p) => s + p.dur, 0);
function animateCell(ts) {
  if (cellPlaying) cellTime += 16;
  if (cellTime > cellTotalDur) cellTime = cellTotalDur;
  drawCellFrame(cellTime);
  requestAnimationFrame(animateCell);
}
function toggleCellAnim() {
  cellPlaying = !cellPlaying;
  document.getElementById('cellPlayBtn').textContent = cellPlaying ? 'â¸ Pause' : 'â–¶ Play';
  document.getElementById('cellPlayBtn').classList.toggle('active', cellPlaying);
}
function resetCellAnim() { cellTime = 0; cellPlaying = true; document.getElementById('cellPlayBtn').textContent = 'â¸ Pause'; document.getElementById('cellPlayBtn').classList.add('active'); }
function stepCell(dir) {
  cellPlaying = false;
  document.getElementById('cellPlayBtn').textContent = 'â–¶ Play';
  document.getElementById('cellPlayBtn').classList.remove('active');
  let target = cellStep + dir;
  target = Math.max(0, Math.min(cellSteps.length - 1, target));
  let t = 0;
  for (let i = 0; i < target; i++) t += cellSteps[i].dur;
  t += cellSteps[target].dur * 0.8;
  cellTime = t;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMATION 4: BURST TIMING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let burstPlaying = true, burstSpeed = 1, burstTime = 0;
const BURST = setupCanvas('burstCanvas');

function drawBurstFrame(t) {
  const { ctx, w, h } = BURST;
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, w, h);

  const ox = 60, oy = 50;
  const frameW = (w - 120);
  const periodMs = 20;
  const totalMs = 80;
  const pxPerMs = frameW / totalMs;
  const cycleDur = 6000;
  const phase = (t % cycleDur) / cycleDur;
  const scanX = ox + phase * frameW;

  // Title
  ctx.font = '600 13px Outfit';
  ctx.fillStyle = C.text;
  ctx.textAlign = 'left';
  ctx.fillText('Radio Frame Timeline (80ms shown â€” 8 frames)', ox, oy - 15);

  // Frame bars
  for (let f = 0; f < 8; f++) {
    const fx = ox + f * 10 * pxPerMs;
    const fWidth = 10 * pxPerMs;
    const isEven = f % 2 === 0;

    // Frame background
    drawRoundRect(ctx, fx, oy, fWidth, 50, 4,
      `rgba(20,30,60,${isEven ? 0.5 : 0.3})`, 'rgba(100,150,255,0.08)');

    // Frame label
    ctx.font = '400 9px "JetBrains Mono"';
    ctx.fillStyle = C.textDim;
    ctx.textAlign = 'center';
    ctx.fillText(`Frame ${f}`, fx + fWidth / 2, oy + 15);
    ctx.fillText(`${f * 10}ms`, fx + fWidth / 2, oy + 28);

    // Half-frame divider
    ctx.beginPath();
    ctx.moveTo(fx + fWidth / 2, oy + 35);
    ctx.lineTo(fx + fWidth / 2, oy + 48);
    ctx.strokeStyle = 'rgba(100,150,255,0.1)';
    ctx.lineWidth = 0.5;
    ctx.stroke();

    ctx.font = '300 7px "JetBrains Mono"';
    ctx.fillStyle = 'rgba(147,197,253,0.25)';
    ctx.fillText('HF0', fx + fWidth / 4, oy + 45);
    ctx.fillText('HF1', fx + 3 * fWidth / 4, oy + 45);
  }

  // SSB Burst Sets (every 20ms = 2 frames, in first half-frame)
  const burstY = oy + 70;
  ctx.font = '500 10px Outfit';
  ctx.fillStyle = C.text;
  ctx.textAlign = 'left';
  ctx.fillText('SSB Burst Sets (Period = 20ms)', ox, burstY - 5);

  for (let b = 0; b < 4; b++) {
    const bx = ox + b * periodMs * pxPerMs;
    const burstWidth = 5 * pxPerMs; // 5ms half-frame

    // Burst container
    drawRoundRect(ctx, bx, burstY + 5, burstWidth, 60, 6,
      'rgba(56,189,248,0.08)', 'rgba(56,189,248,0.2)');

    // 8 SSB beams within
    const ssbW = burstWidth / 9;
    for (let s = 0; s < 8; s++) {
      const sx = bx + 3 + s * ssbW;
      const isPast = sx + ssbW < scanX;
      const isNow = sx < scanX && sx + ssbW >= scanX;
      const alpha = isNow ? 0.6 : isPast ? 0.35 : 0.1;

      drawRoundRect(ctx, sx, burstY + 12, ssbW - 1, 46, 2,
        beamColors[s] + alpha + ')', null);

      if (isNow) {
        ctx.save();
        ctx.shadowColor = beamColors[s] + '0.6)';
        ctx.shadowBlur = 10;
        drawRoundRect(ctx, sx, burstY + 12, ssbW - 1, 46, 2,
          beamColors[s] + '0.3)', beamColors[s] + '0.7)');
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // Burst label
    ctx.font = '500 8px "JetBrains Mono"';
    ctx.fillStyle = C.pssG + '0.6)';
    ctx.textAlign = 'center';
    ctx.fillText(`Burst ${b}`, bx + burstWidth / 2, burstY + 72);
  }

  // Scan line
  ctx.beginPath();
  ctx.moveTo(scanX, oy - 5);
  ctx.lineTo(scanX, burstY + 80);
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([4, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Triangle marker
  ctx.beginPath();
  ctx.moveTo(scanX - 6, oy - 8);
  ctx.lineTo(scanX + 6, oy - 8);
  ctx.lineTo(scanX, oy - 2);
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fill();

  // â”€â”€ Slot detail view â”€â”€
  const slotY = burstY + 100;
  drawRoundRect(ctx, ox, slotY, frameW, 140, 10, 'rgba(10,16,35,0.6)', 'rgba(100,150,255,0.06)');

  ctx.font = '500 10px Outfit';
  ctx.fillStyle = C.text;
  ctx.textAlign = 'left';
  ctx.fillText('Slot-Level Detail â€” Case A (15 kHz SCS): SSB starts at symbols {2, 8} + 14n', ox + 16, slotY + 20);

  // Draw 2 slots (28 symbols for 15kHz)
  const slotAreaX = ox + 16;
  const slotAreaW = frameW - 32;
  const symW2 = slotAreaW / 28;

  for (let s = 0; s < 28; s++) {
    const sx = slotAreaX + s * symW2;
    // Check if this is an SSB start symbol (Case A: {2,8} + 14n)
    const ssbStarts = [2, 8, 16, 22];
    const isSSB = ssbStarts.some(start => s >= start && s < start + 4);
    const ssbOffset = ssbStarts.find(start => s >= start && s < start + 4);
    const symInSSB = isSSB ? s - ssbOffset : -1;

    let fillColor = 'rgba(30,40,60,0.4)';
    let borderColor = 'rgba(100,150,255,0.06)';

    if (isSSB) {
      if (symInSSB === 0) { fillColor = C.pssG + '0.3)'; borderColor = C.pssG + '0.5)'; }
      else if (symInSSB === 2) { fillColor = C.sssG + '0.3)'; borderColor = C.sssG + '0.5)'; }
      else { fillColor = C.pbchG + '0.25)'; borderColor = C.pbchG + '0.4)'; }
    }

    // Highlight scan position
    const symCenter = sx + symW2 / 2;
    const distToScan = Math.abs(symCenter - (scanX - ox + slotAreaX - ox));

    drawRoundRect(ctx, sx + 0.5, slotY + 35, symW2 - 1, 70, 2, fillColor, borderColor);

    // Symbol number
    if (s % 2 === 0) {
      ctx.font = '300 7px "JetBrains Mono"';
      ctx.fillStyle = C.textDim;
      ctx.textAlign = 'center';
      ctx.fillText(s.toString(), sx + symW2 / 2, slotY + 118);
    }

    // SSB signal labels
    if (isSSB && symInSSB === 0) {
      ctx.font = '600 8px "JetBrains Mono"';
      ctx.fillStyle = C.pss;
      ctx.textAlign = 'center';
      ctx.fillText('P', sx + symW2 / 2, slotY + 60);
    } else if (isSSB && symInSSB === 2) {
      ctx.font = '600 8px "JetBrains Mono"';
      ctx.fillStyle = C.sss;
      ctx.fillText('S', sx + symW2 / 2, slotY + 60);
    } else if (isSSB) {
      ctx.font = '600 8px "JetBrains Mono"';
      ctx.fillStyle = C.pbch;
      ctx.fillText('B', sx + symW2 / 2, slotY + 60);
    }
  }

  // Slot divider labels
  ctx.font = '400 8px "JetBrains Mono"';
  ctx.fillStyle = C.textDim;
  ctx.textAlign = 'center';
  ctx.fillText('Slot 0 (14 symbols)', slotAreaX + 7 * symW2, slotY + 132);
  ctx.fillText('Slot 1 (14 symbols)', slotAreaX + 21 * symW2, slotY + 132);

  // Slot divider line
  ctx.beginPath();
  ctx.moveTo(slotAreaX + 14 * symW2, slotY + 33);
  ctx.lineTo(slotAreaX + 14 * symW2, slotY + 108);
  ctx.strokeStyle = 'rgba(147,197,253,0.2)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  ctx.stroke();
  ctx.setLineDash([]);

  // SSB bracket labels
  const brackets = [
    { start: 2, label: 'SSB #0' },
    { start: 8, label: 'SSB #1' },
    { start: 16, label: 'SSB #2' },
    { start: 22, label: 'SSB #3' },
  ];
  brackets.forEach(br => {
    const bx1 = slotAreaX + br.start * symW2;
    const bx2 = slotAreaX + (br.start + 4) * symW2;
    ctx.beginPath();
    ctx.moveTo(bx1, slotY + 30);
    ctx.lineTo(bx1, slotY + 27);
    ctx.lineTo(bx2, slotY + 27);
    ctx.lineTo(bx2, slotY + 30);
    ctx.strokeStyle = 'rgba(147,197,253,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.font = '500 7px "JetBrains Mono"';
    ctx.fillStyle = 'rgba(147,197,253,0.5)';
    ctx.textAlign = 'center';
    ctx.fillText(br.label, (bx1 + bx2) / 2, slotY + 24);
  });

  const timeMs = (phase * totalMs).toFixed(1);
  document.getElementById('burstStatus').innerHTML =
    `<span class="label">Time: ${timeMs} ms</span> â€” SSB burst every 20ms, 8 beams per burst in 5ms half-frame | P=PSS, S=SSS, B=PBCH`;
}

function animateBurst(ts) {
  if (burstPlaying) burstTime += 16 * burstSpeed;
  drawBurstFrame(burstTime);
  requestAnimationFrame(animateBurst);
}
function toggleBurstAnim() {
  burstPlaying = !burstPlaying;
  document.getElementById('burstPlayBtn').textContent = burstPlaying ? 'â¸ Pause' : 'â–¶ Play';
  document.getElementById('burstPlayBtn').classList.toggle('active', burstPlaying);
}
function resetBurstAnim() { burstTime = 0; }


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMATION 5: PBCH DECODE PIPELINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let pbchPlaying = true, pbchTime = 0, pbchStep = 0;
const PBCH = setupCanvas('pbchCanvas');

const pbchStages = [
  { name: 'DMRS Channel Est.', dur: 2800, color: C.dmrs, colorG: C.dmrsG,
    sub: 'Extract 144 DMRS REs â†’ estimate H(f) â†’ equalize PBCH' },
  { name: 'PBCH Demodulation', dur: 2800, color: C.pbch, colorG: C.pbchG,
    sub: '432 REs â†’ QPSK soft demod â†’ 864 soft bits â†’ descramble' },
  { name: 'Rate De-matching', dur: 2500, color: '#60a5fa', colorG: 'rgba(96,165,250,',
    sub: '864 bits â†’ rate de-match â†’ polar code block (512 bits)' },
  { name: 'Polar Decode', dur: 2800, color: C.sss, colorG: C.sssG,
    sub: 'Successive cancellation list decode â†’ 56 info bits â†’ CRC-24C check' },
  { name: 'MIB Extraction', dur: 3500, color: C.pss, colorG: C.pssG,
    sub: 'Extract 24-bit MIB â†’ SFN, SCS, CORESET#0, k_SSB, cell barred' },
];

function drawPbchFrame(t) {
  const { ctx, w, h } = PBCH;
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, w, h);

  let elapsed = 0, current = 0, pt = 0;
  for (let i = 0; i < pbchStages.length; i++) {
    if (t < elapsed + pbchStages[i].dur) {
      current = i;
      pt = (t - elapsed) / pbchStages[i].dur;
      break;
    }
    elapsed += pbchStages[i].dur;
    if (i === pbchStages.length - 1) { current = i; pt = 1; }
  }
  pbchStep = current;
  const stage = pbchStages[current];

  // â”€â”€ Pipeline bar â”€â”€
  const pipeX = 60, pipeY = 30, pipeW = w - 120;
  const stageW = pipeW / 5;

  for (let i = 0; i < 5; i++) {
    const sx = pipeX + i * stageW;
    const s = pbchStages[i];
    const isActive = i === current;
    const isDone = i < current;

    drawRoundRect(ctx, sx + 3, pipeY, stageW - 6, 55, 8,
      s.colorG + (isActive ? '0.35)' : isDone ? '0.2)' : '0.05)'),
      s.colorG + (isActive ? '0.6)' : '0.12)'));

    if (isActive) {
      const barW = (stageW - 14) * ease(pt);
      drawRoundRect(ctx, sx + 7, pipeY + 45, barW, 4, 2, s.colorG + '0.5)', null);
    }

    ctx.font = '500 9px "JetBrains Mono"';
    ctx.textAlign = 'center';
    ctx.fillStyle = isDone ? s.color : isActive ? s.color : C.textDim;
    ctx.fillText(`${i + 1}. ${s.name}`, sx + stageW / 2, pipeY + 25);

    if (isDone) {
      ctx.font = '600 12px Outfit';
      ctx.fillText('âœ“', sx + stageW / 2, pipeY + 42);
    }

    if (i < 4) {
      ctx.beginPath();
      ctx.moveTo(sx + stageW - 2, pipeY + 27);
      ctx.lineTo(sx + stageW + 4, pipeY + 27);
      ctx.strokeStyle = i < current ? 'rgba(147,197,253,0.4)' : 'rgba(147,197,253,0.08)';
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  // â”€â”€ Main visualization area â”€â”€
  const mainY = 110;
  const mainH = h - mainY - 30;

  drawRoundRect(ctx, 60, mainY, w - 120, mainH, 14, 'rgba(10,16,35,0.6)', stage.colorG + '0.12)');

  // Stage title
  ctx.font = '700 20px Outfit';
  ctx.textAlign = 'left';
  ctx.fillStyle = stage.color;
  ctx.fillText(stage.name, 90, mainY + 35);

  ctx.font = '300 11px "JetBrains Mono"';
  ctx.fillStyle = stage.colorG + '0.6)';
  ctx.fillText(stage.sub, 90, mainY + 55);

  // â”€â”€ Stage-specific visualizations â”€â”€
  if (current === 4) {
    // MIB bit field visualization
    const fields = [
      { name: 'systemFrameNumber', bits: '6 bits (MSBs)', w: 110, color: C.pss },
      { name: 'subCarrierSpacingCommon', bits: '1 bit', w: 60, color: C.sss },
      { name: 'ssb-SubcarrierOffset', bits: '4 bits', w: 80, color: C.dmrs },
      { name: 'dmrs-TypeA-Position', bits: '1 bit', w: 55, color: C.pbch },
      { name: 'pdcch-ConfigSIB1', bits: '8 bits', w: 120, color: '#60a5fa' },
      { name: 'cellBarred', bits: '1 bit', w: 50, color: '#f472b6' },
      { name: 'intraFreqReselection', bits: '1 bit', w: 55, color: '#fb923c' },
      { name: 'spare', bits: '1 bit', w: 40, color: '#64748b' },
    ];

    ctx.font = '600 12px Outfit';
    ctx.fillStyle = C.white;
    ctx.fillText('MIB Bit Fields (24 bits)', 90, mainY + 85);

    let bx = 90;
    const by = mainY + 100;
    fields.forEach((f, i) => {
      const showT = ease(Math.max(0, Math.min(1, (pt - i * 0.08) / 0.3)));
      if (showT <= 0) return;

      ctx.save();
      ctx.globalAlpha = showT;
      drawRoundRect(ctx, bx, by, f.w, 35, 6, f.color, null);
      ctx.font = '600 8px "JetBrains Mono"';
      ctx.fillStyle = '#0a0e1a';
      ctx.textAlign = 'center';
      ctx.fillText(f.bits, bx + f.w / 2, by + 15);
      ctx.font = '300 7px "JetBrains Mono"';
      ctx.fillText(f.name.substring(0, 12), bx + f.w / 2, by + 27);
      ctx.globalAlpha = 1;
      ctx.restore();
      bx += f.w + 4;
    });

    // Decoded values
    const vals = [
      'SFN[9:4] = 0b001010 â†’ Frame 40',
      'SCS Common = 0 â†’ 15 kHz',
      'k_SSB = 0b0110 â†’ offset 6',
      'CORESET#0: controlResourceSetZero=10, searchSpaceZero=4',
      'cellBarred = 0 â†’ Not barred',
      'intraFreqReselection = 0 â†’ Allowed',
    ];

    const valY = by + 55;
    vals.forEach((v, i) => {
      const showT = ease(Math.max(0, Math.min(1, (pt - 0.3 - i * 0.08) / 0.25)));
      if (showT <= 0) return;
      ctx.save();
      ctx.globalAlpha = showT;
      ctx.font = '400 10px "JetBrains Mono"';
      ctx.fillStyle = 'rgba(200,215,245,0.75)';
      ctx.textAlign = 'left';
      ctx.fillText('â€º ' + v, 100, valY + i * 22);
      ctx.globalAlpha = 1;
      ctx.restore();
    });

    // Next steps box
    if (pt > 0.7) {
      const nextY = valY + vals.length * 22 + 15;
      const nextAlpha = ease(Math.min((pt - 0.7) / 0.3, 1));
      ctx.save();
      ctx.globalAlpha = nextAlpha;
      drawRoundRect(ctx, 90, nextY, 500, 50, 8, 'rgba(96,165,250,0.1)', 'rgba(96,165,250,0.25)');
      ctx.font = '600 11px Outfit';
      ctx.fillStyle = '#60a5fa';
      ctx.textAlign = 'left';
      ctx.fillText('â†’ Next: Use CORESET#0 to read PDCCH â†’ DCI schedules SIB1 on PDSCH', 108, nextY + 20);
      ctx.font = '300 10px "JetBrains Mono"';
      ctx.fillStyle = 'rgba(96,165,250,0.5)';
      ctx.fillText('SIB1 contains full cell config, RACH parameters, BWP settings', 108, nextY + 38);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

  } else {
    // Generic data flow visualization for stages 0-3
    const flowY = mainY + 80;
    const flowH = 200;
    const flowX = 90;
    const flowW = w - 180;

    // Input box
    const inputLabels = ['144 DMRS REs', '432 PBCH REs', '864 soft bits', '512 code bits'];
    const outputLabels = ['H(f) estimate', '864 soft bits', '512 code block', '56 info bits'];
    const processLabels = ['LS/MMSE Estimation', 'QPSK Soft Demod', 'Rate De-match', 'SCL Decode'];

    const inW = 160, outW = 160, procW = 200;
    const boxH = 60;

    // Input
    const inAlpha = ease(Math.min(pt * 3, 1));
    ctx.save();
    ctx.globalAlpha = inAlpha;
    drawRoundRect(ctx, flowX, flowY, inW, boxH, 10, stage.colorG + '0.2)', stage.colorG + '0.4)');
    ctx.font = '600 11px Outfit';
    ctx.fillStyle = stage.color;
    ctx.textAlign = 'center';
    ctx.fillText('Input', flowX + inW / 2, flowY + 22);
    ctx.font = '400 10px "JetBrains Mono"';
    ctx.fillStyle = stage.colorG + '0.7)';
    ctx.fillText(inputLabels[current], flowX + inW / 2, flowY + 42);
    ctx.globalAlpha = 1;
    ctx.restore();

    // Animated data particles flowing
    const procX = flowX + inW + 60;
    for (let p = 0; p < 8; p++) {
      const pPhase = ((pt * 3 + p * 0.12) % 1);
      if (pPhase > 1 || pt < 0.1) continue;
      const px = flowX + inW + pPhase * 55;
      const py = flowY + boxH / 2 + Math.sin(pPhase * Math.PI * 2 + p) * 8;
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fillStyle = stage.colorG + (1 - pPhase) * 0.6 + ')';
      ctx.fill();
    }

    // Process box
    const procAlpha = ease(Math.max(0, Math.min(1, (pt - 0.15) / 0.3)));
    ctx.save();
    ctx.globalAlpha = procAlpha;
    drawRoundRect(ctx, procX, flowY - 10, procW, boxH + 20, 12,
      'rgba(20,30,60,0.6)', stage.colorG + '0.3)');

    // Animated processing indicator
    if (pt > 0.2 && pt < 0.8) {
      const procPhase = ((pt - 0.2) / 0.6);
      drawRoundRect(ctx, procX + 8, flowY + boxH + 2, (procW - 16) * procPhase, 4, 2,
        stage.colorG + '0.5)', null);
    }

    ctx.font = '600 13px Outfit';
    ctx.fillStyle = C.white;
    ctx.textAlign = 'center';
    ctx.fillText(processLabels[current], procX + procW / 2, flowY + 20);
    ctx.font = '400 10px "JetBrains Mono"';
    ctx.fillStyle = stage.colorG + '0.6)';
    ctx.fillText('Processing...', procX + procW / 2, flowY + 42);
    ctx.globalAlpha = 1;
    ctx.restore();

    // Output particles
    const outX = procX + procW + 60;
    for (let p = 0; p < 8; p++) {
      const pPhase = ((pt * 2 - 0.5 + p * 0.12) % 1);
      if (pPhase < 0 || pPhase > 1 || pt < 0.4) continue;
      const px = procX + procW + pPhase * 55;
      const py = flowY + boxH / 2 + Math.sin(pPhase * Math.PI * 2 + p) * 8;
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fillStyle = stage.colorG + (1 - pPhase) * 0.6 + ')';
      ctx.fill();
    }

    // Output box
    const outAlpha = ease(Math.max(0, Math.min(1, (pt - 0.5) / 0.3)));
    ctx.save();
    ctx.globalAlpha = outAlpha;
    drawRoundRect(ctx, outX, flowY, outW, boxH, 10, stage.colorG + '0.2)', stage.colorG + '0.4)');
    ctx.font = '600 11px Outfit';
    ctx.fillStyle = stage.color;
    ctx.textAlign = 'center';
    ctx.fillText('Output', outX + outW / 2, flowY + 22);
    ctx.font = '400 10px "JetBrains Mono"';
    ctx.fillStyle = stage.colorG + '0.7)';
    ctx.fillText(outputLabels[current], outX + outW / 2, flowY + 42);
    ctx.globalAlpha = 1;
    ctx.restore();

    // Technical detail below
    const techDetails = [
      ['DMRS pattern: every 4th subcarrier', 'v = N_ID^cell mod 4', 'LS estimation: H = Y/X', 'Interpolation across 240 SCs'],
      ['Equalized: Y_eq = Y / H(f)', 'QPSK: 2 bits per RE', 'Total: 432 Ã— 2 = 864 bits', 'Descramble with c_init = N_ID^cell'],
      ['Circular buffer extraction', 'E = 864 (coded bits)', 'K = 512 (polar code size)', 'N = 56 (info + CRC)'],
      ['SCL decoder, L = 8 paths', 'CRC-aided: 24-bit CRC-24C', 'Payload: 32 bits (MIB)', '+ 24 bits CRC = 56 total'],
    ];

    const detailY = flowY + boxH + 40;
    techDetails[current].forEach((d, i) => {
      const dAlpha = ease(Math.max(0, Math.min(1, (pt - 0.3 - i * 0.1) / 0.25)));
      if (dAlpha <= 0) return;
      ctx.save();
      ctx.globalAlpha = dAlpha;
      ctx.font = '400 10px "JetBrains Mono"';
      ctx.fillStyle = 'rgba(200,215,245,0.7)';
      ctx.textAlign = 'left';
      ctx.fillText('â€º ' + d, 100, detailY + i * 24);
      ctx.globalAlpha = 1;
      ctx.restore();
    });
  }

  document.getElementById('pbchStatus').innerHTML =
    `<span class="label">Stage ${current + 1}/5: ${stage.name}</span> â€” ${stage.sub}`;
}

const pbchTotalDur = pbchStages.reduce((s, p) => s + p.dur, 0);
function animatePbch(ts) {
  if (pbchPlaying) pbchTime += 16;
  if (pbchTime > pbchTotalDur) pbchTime = pbchTotalDur;
  drawPbchFrame(pbchTime);
  requestAnimationFrame(animatePbch);
}
function togglePbchAnim() {
  pbchPlaying = !pbchPlaying;
  document.getElementById('pbchPlayBtn').textContent = pbchPlaying ? 'â¸ Pause' : 'â–¶ Play';
  document.getElementById('pbchPlayBtn').classList.toggle('active', pbchPlaying);
}
function resetPbchAnim() { pbchTime = 0; pbchPlaying = true; document.getElementById('pbchPlayBtn').textContent = 'â¸ Pause'; document.getElementById('pbchPlayBtn').classList.add('active'); }
function stepPbch(dir) {
  pbchPlaying = false;
  document.getElementById('pbchPlayBtn').textContent = 'â–¶ Play';
  document.getElementById('pbchPlayBtn').classList.remove('active');
  let target = pbchStep + dir;
  target = Math.max(0, Math.min(pbchStages.length - 1, target));
  let t = 0;
  for (let i = 0; i < target; i++) t += pbchStages[i].dur;
  t += pbchStages[target].dur * 0.8;
  pbchTime = t;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START ALL ANIMATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
requestAnimationFrame(animateBeam);
requestAnimationFrame(animateGrid);
requestAnimationFrame(animateCell);
requestAnimationFrame(animateBurst);
requestAnimationFrame(animatePbch);

// Intersection observer for nav highlighting
const sections = document.querySelectorAll('.section');
const navBtns = document.querySelectorAll('.nav-btn');
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const id = entry.target.id;
      navBtns.forEach((btn, i) => {
        btn.classList.toggle('active',
          btn.getAttribute('onclick')?.includes(id));
      });
    }
  });
}, { threshold: 0.3 });
sections.forEach(s => observer.observe(s));
</script>
</body>
</html>
