<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5G NR Polar Coding — Interactive Simulation</title>
    <style>
        :root {
            --bg-dark: #0a0e14;
            --panel-bg: #161b22;
            --accent-cyan: #00f2ff;
            --accent-blue: #0070ff;
            --text-main: #e6edf3;
            --text-dim: #8b949e;
            --border: #30363d;
            --frozen: #444c56;
            --info: #238636;
            --highlight: #f85149;
        }

        * { box-sizing: border-box; }
        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Layout */
        header {
            padding: 2rem;
            background: linear-gradient(180deg, #161b22 0%, #0a0e14 100%);
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        section {
            margin-bottom: 4rem;
            padding: 2rem;
            background: var(--panel-bg);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        h1, h2, h3 {
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Section 1: Theory */
        .theory-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .theory-content {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 1rem;
            font-size: 0.95rem;
        }
        .theory-content::-webkit-scrollbar { width: 6px; }
        .theory-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }

        /* Section 2: Flow */
        .flow-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2rem 0;
        }
        .flow-step {
            background: var(--bg-dark);
            border: 1px solid var(--accent-cyan);
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            flex: 1;
            margin: 0 10px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
        }
        .flow-step:hover { background: var(--accent-blue); color: white; }
        .arrow { color: var(--accent-cyan); font-weight: bold; }

        /* Section 3: Simulator */
        .sim-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            background: var(--bg-dark);
            padding: 1.5rem;
            border-radius: 4px;
        }

        .control-group { display: flex; flex-direction: column; }
        label { font-size: 0.8rem; color: var(--text-dim); margin-bottom: 5px; }
        select, input, button {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            color: white;
            padding: 8px;
            border-radius: 4px;
            outline: none;
        }
        button {
            background: var(--accent-blue);
            cursor: pointer;
            font-weight: bold;
            border: none;
            transition: 0.2s;
        }
        button:hover { background: var(--accent-cyan); color: var(--bg-dark); }

        .viz-area {
            background: #000;
            padding: 2rem;
            border-radius: 4px;
            overflow-x: auto;
            position: relative;
        }

        /* SVG Butterfly Styles */
        svg { background: #000; display: block; margin: auto; }
        .node { r: 5; fill: var(--border); transition: 0.3s; }
        .line { stroke: #333; stroke-width: 1; transition: 0.3s; }
        .line-active { stroke: var(--accent-cyan); stroke-width: 2; }
        .bit-label { font-size: 12px; fill: var(--text-dim); font-family: monospace; }
        .frozen-label { fill: #ff7b72; font-weight: bold; }
        .info-label { fill: #7ee787; font-weight: bold; }

        /* Results Panel */
        #results-panel {
            margin-top: 1rem;
            padding: 1rem;
            background: #0d1117;
            border-left: 4px solid var(--accent-cyan);
        }

        /* Decoding Visual */
        .tree-viz {
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px dashed var(--border);
        }

        .pulse { animation: pulse-animation 2s infinite; }
        @keyframes pulse-animation {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>

<header>
    <h1>5G NR Polar Coding — Technical Visualization</h1>
    <p style="color: var(--text-dim);">3GPP TS 38.212 Physical Layer Procedures for Control Channels</p>
</header>

<div class="container">

    <!-- SECTION 1: THEORY -->
    <section>
        <h2>1. Theory & Channel Polarization</h2>
        <div class="theory-grid">
            <div class="theory-content">
                <h3>Fundamentals</h3>
                <p>Polar coding, proposed by Erdal Arikan in 2009, is the first channel coding technique proven to achieve <b>Shannon Capacity</b> for symmetric binary-input memoryless channels. In 5G NR, Polar codes are standardized for the <b>PDCCH</b> (Physical Downlink Control Channel) and <b>PBCH</b> (Physical Broadcast Channel).</p>
                
                <h3>Channel Polarization</h3>
                <p>The core concept is "Channel Polarization." By recursively combining $N$ identical copies of a noisy channel, we create $N$ virtual channels. As $N \to \infty$, these virtual channels polarize: they become either perfectly noiseless (reliable) or completely noisy (unreliable).</p>
                
                <h3>Frozen Bits vs Information Bits</h3>
                <ul>
                    <li><b>Information Bits (K):</b> Placed in the $K$ most reliable virtual channels.</li>
                    <li><b>Frozen Bits (N-K):</b> Placed in the remaining $N-K$ unreliable channels. These bits are "frozen" to a known value, typically 0.</li>
                </ul>

                <h3>3GPP Standards</h3>
                <p>For 5G NR, a mother code size $N$ is chosen as a power of 2 ($2^n$). The reliability sequence is predefined in TS 38.212, allowing both transmitter and receiver to agree on which indices are frozen without dynamic signaling.</p>
            </div>
            <div style="background: var(--bg-dark); padding: 1rem; border-radius: 4px;">
                <h3 style="font-size: 0.9rem;">Mathematical Kernel</h3>
                <p style="font-family: monospace; font-size: 0.8rem; background: #000; padding: 10px; border: 1px solid var(--border);">
                    G_2 = [1 0]<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1 1]<br><br>
                    G_N = G_2 ⊗ G_{N/2}
                </p>
                <p style="font-size: 0.85rem; color: var(--text-dim);">The encoding process is a linear transformation: <b>x = uG</b>, where <b>u</b> is the input vector (info + frozen) and <b>G</b> is the generator matrix.</p>
            </div>
        </div>
    </section>

    <!-- SECTION 2: PROCESS VISUALIZATION -->
    <section>
        <h2>2. Process Workflow</h2>
        <div class="flow-container">
            <div class="flow-step" onclick="alert('Information bits (K) are gathered from the MAC layer.')">INPUT BITS</div>
            <div class="arrow">→</div>
            <div class="flow-step" onclick="alert('Bits are mapped to reliable indices. Others set to 0.')">BIT PLACEMENT</div>
            <div class="arrow">→</div>
            <div class="flow-step" onclick="alert('Recursive XOR operations transform the vector.')">POLAR TRANSFORM</div>
            <div class="arrow">→</div>
            <div class="flow-step" onclick="alert('Circular buffer mapping for the physical resource.')">RATE MATCHING</div>
            <div class="arrow">→</div>
            <div class="flow-step" onclick="alert('Physical transmission on PDCCH/PBCH.')">TRANSMISSION</div>
        </div>
    </section>

    <!-- SECTION 3: INTERACTIVE SIMULATOR -->
    <section>
        <h2>3. Interactive Polar Encoder</h2>
        <div class="sim-controls">
            <div class="control-group">
                <label>Mother Code Length (N)</label>
                <select id="selectN" onchange="resetSim()">
                    <option value="8">N = 8</option>
                    <option value="16">N = 16</option>
                    <option value="32">N = 32</option>
                </select>
            </div>
            <div class="control-group">
                <label>Info Bits (K)</label>
                <input type="number" id="inputK" value="4" min="1" max="7" onchange="validateK()">
            </div>
            <div class="control-group">
                <label>Input Data (Hex)</label>
                <input type="text" id="inputData" value="A" maxlength="8">
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button onclick="runSimulation()">RUN ENCODER</button>
            </div>
        </div>

        <div class="viz-area" id="vizArea">
            <svg id="butterflySvg" width="1000" height="400"></svg>
        </div>

        <div id="results-panel" style="display: none;">
            <h3>Simulation Analysis</h3>
            <div id="resultsText" style="font-family: monospace; font-size: 0.9rem;"></div>
        </div>
    </section>

    <!-- SECTION 4: DECODING CONCEPT -->
    <section>
        <h2>4. Successive Cancellation Decoding</h2>
        <div class="theory-grid">
            <div style="background: var(--bg-dark); padding: 1rem; border-radius: 4px; text-align: center;">
                <div class="tree-viz">
                    <svg width="200" height="150">
                        <circle cx="100" cy="30" r="5" fill="var(--accent-cyan)" />
                        <line x1="100" y1="30" x2="60" y2="80" stroke="var(--border)" />
                        <line x1="100" y1="30" x2="140" y2="80" stroke="var(--border)" />
                        <text x="50" y="110" fill="var(--text-dim)" font-size="10">Left (f)</text>
                        <text x="130" y="110" fill="var(--text-dim)" font-size="10">Right (g)</text>
                    </svg>
                </div>
                <p style="font-size: 0.8rem; color: var(--text-dim);">Binary Tree Representation</p>
            </div>
            <div>
                <h3>SC Decoding Process</h3>
                <p>The receiver uses <b>Successive Cancellation (SC)</b>. Decisions are made bit-by-bit from index $0$ to $N-1$.</p>
                <ul>
                    <li>If index $i$ is a <b>Frozen Bit</b>, the decoder sets $\hat{u}_i = 0$ automatically.</li>
                    <li>If index $i$ is an <b>Information Bit</b>, the decoder makes a hard decision based on the Likelihood Ratio (LLR).</li>
                </ul>
                <p>Modern 5G systems use <b>SC-List (SCL)</b> decoding, which keeps multiple paths open and uses a CRC to pick the correct one, significantly improving performance.</p>
            </div>
        </div>
    </section>

</div>

<script>
    // Simplified Reliability Sequences for N=8, 16, 32 
    // (Based on density evolution / 3GPP sequence ordering)
    const reliability = {
        8: [0, 1, 2, 4, 3, 5, 6, 7],
        16: [0, 1, 2, 4, 8, 3, 5, 6, 9, 10, 12, 7, 11, 13, 14, 15],
        32: [0, 1, 2, 4, 8, 16, 3, 5, 6, 9, 10, 17, 12, 18, 20, 24, 7, 11, 13, 19, 14, 21, 22, 25, 26, 28, 15, 23, 27, 29, 30, 31]
    };

    function validateK() {
        const N = parseInt(document.getElementById('selectN').value);
        const kInput = document.getElementById('inputK');
        if (kInput.value >= N) kInput.value = N - 1;
        if (kInput.value < 1) kInput.value = 1;
    }

    function resetSim() {
        validateK();
        document.getElementById('butterflySvg').innerHTML = '';
        document.getElementById('results-panel').style.display = 'none';
    }

    function runSimulation() {
        const N = parseInt(document.getElementById('selectN').value);
        const K = parseInt(document.getElementById('inputK').value);
        const hexData = document.getElementById('inputData').value;
        
        // Convert hex to bits
        let dataBits = parseInt(hexData, 16).toString(2).padStart(K, '0').split('').map(Number);
        if (dataBits.length > K) dataBits = dataBits.slice(-K);

        // 1. Identify Frozen vs Info indices
        const seq = reliability[N];
        const infoIndices = seq.slice(N - K);
        const u = new Array(N).fill(0);
        
        let dIdx = 0;
        for (let i = 0; i < N; i++) {
            if (infoIndices.includes(i)) {
                u[i] = dataBits[dIdx++] || 0;
            }
        }

        // 2. Perform Polar Transform (XOR Butterfly)
        const stages = Math.log2(N);
        const xorMatrix = []; // To store intermediate steps
        xorMatrix[0] = [...u];

        for (let s = 1; s <= stages; s++) {
            const step = Math.pow(2, s - 1);
            const currentStage = new Array(N);
            for (let i = 0; i < N; i++) {
                if ((i & step) === 0) {
                    // Top branch: xor logic
                    currentStage[i] = xorMatrix[s-1][i] ^ xorMatrix[s-1][i + step];
                } else {
                    // Bottom branch: direct
                    currentStage[i] = xorMatrix[s-1][i];
                }
            }
            xorMatrix[s] = currentStage;
        }

        drawButterfly(N, xorMatrix, infoIndices);
        showResults(u, xorMatrix[stages], infoIndices);
    }

    function drawButterfly(N, matrix, infoIndices) {
        const svg = document.getElementById('butterflySvg');
        svg.innerHTML = '';
        const stages = matrix.length - 1;
        const spacingX = 900 / (stages + 1);
        const spacingY = Math.min(40, 380 / N);
        const offsetX = 50;
        const offsetY = 20;

        // Draw Lines (Connections)
        for (let s = 0; s < stages; s++) {
            const step = Math.pow(2, s);
            for (let i = 0; i < N; i++) {
                const x1 = offsetX + s * spacingX;
                const x2 = offsetX + (s + 1) * spacingX;
                const y1 = offsetY + i * spacingY;
                
                // Straight connection
                drawLine(svg, x1, y1, x2, y1);

                // XOR diagonal
                if ((i & step) === 0) {
                    drawLine(svg, x1, y1 + step * spacingY, x2, y1);
                }
            }
        }

        // Draw Nodes and Labels
        for (let s = 0; s <= stages; s++) {
            for (let i = 0; i < N; i++) {
                const x = offsetX + s * spacingX;
                const y = offsetY + i * spacingY;
                
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", 4);
                circle.setAttribute("class", "node");
                svg.appendChild(circle);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", s === 0 ? x - 35 : x + 10);
                text.setAttribute("y", y + 4);
                text.setAttribute("class", "bit-label");
                
                if (s === 0) {
                    const isInfo = infoIndices.includes(i);
                    text.textContent = `u${i}:${matrix[s][i]}`;
                    text.classList.add(isInfo ? 'info-label' : 'frozen-label');
                } else if (s === stages) {
                    text.textContent = `x${i}:${matrix[s][i]}`;
                    text.setAttribute("fill", "var(--accent-cyan)");
                } else {
                    text.textContent = matrix[s][i];
                }
                svg.appendChild(text);
            }
        }
    }

    function drawLine(svg, x1, y1, x2, y2) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("class", "line");
        svg.appendChild(line);
    }

    function showResults(u, x, infoIndices) {
        const panel = document.getElementById('results-panel');
        const text = document.getElementById('resultsText');
        panel.style.display = 'block';

        let html = `<strong>Input Vector (u):</strong> [${u.join(', ')}]<br>`;
        html += `<strong>Encoded Vector (x):</strong> <span style="color:var(--accent-cyan)">[${x.join(', ')}]</span><br><br>`;
        html += `<strong>Reliability Mapping:</strong><br>`;
        
        u.forEach((val, i) => {
            const type = infoIndices.includes(i) ? 
                '<span style="color:#7ee787">[INFO]</span>' : 
                '<span style="color:#ff7b72">[FROZEN]</span>';
            html += `Index ${i.toString().padStart(2, '0')}: ${type} &nbsp; Bit Value: ${val}<br>`;
        });

        text.innerHTML = html;
    }

    // Initialize logic
    window.onload = () => {
        runSimulation();
    };
</script>

</body>
</html>